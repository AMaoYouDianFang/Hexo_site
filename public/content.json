{"pages":[{"title":"About","text":"优秀的人不是不合群，而是他们合群的人里面没有你。","link":"/about/index.html"},{"title":"Gallery","text":"Justified-gallery 相册页: lightGallery 相册页:","link":"/gallery/index.html"},{"title":"Links","text":"申请友链须知 原则上只和技术、情感类博客互换友链，且具有原创高质量文章优先。 不与含有色情、暴力、政治敏感或其他法律法规禁止的网站互换。 申请链接前请先添加本博链接，通过本友链页面留言或邮件告知。 请提供网站名称、网站链接、网站描述（12字以内）、网站图标或头像。 本站会定期对所有友链进行检查，如果发现一月内不能访问或者数月内没有内容更新可能会取消该友链。 友情链接 一见倾心 你要很酷，世界才不会残酷 水寒的博客 安卓、前端、物联网大佬 Jitwxs Java 后端开发大佬 致永远-For Aye 笔墨写春秋,挥毫斥方遒 过客~励む 努力，为了将来更好的选择 果果小师弟 一个喜欢嵌入式的小码农 GeekInns 努力努力，学习不易 CloudCver 意犹未尽 人工智能、CV小白 一见倾心 虚位以待","link":"/links/index.html"}],"posts":[{"title":"Icarus 主题网站优化（bug记录）","text":"记录我的网站目标及优化之路，感谢以下大佬的创作与开发（不分先后）： Thanks 大佬 ppoffice Ray’s Blog dp2px removeif jitwxs imaegoo alphalxy Evan zazdream cxy35 Anne Wu yafine ToDo 计划 粒子时钟（加强版） 文章页 双栏布局 /减少不必要的部件 自动刷新md内容方便预览 底部备案、文章版权、永久链接格式 黑夜模式 主页添加bio(一句话) 图片居中/相册间隙 友链页布局修改（三栏） 关于页面内容更新(加音乐) 主页添加部件 最新评论 主页添加部件 添加推荐文章 增加页面 豆瓣电影 增加页面 豆瓣书单 增加电子书阅读页面(gitbook) 增加网易云音乐页面 关于页面加入时间线 归档页添加文章贡献概览 置顶文章功能 加密文章功能（鸡肋） 文章列表评论数显示 增加页面 碎碎念（个人吐槽、心情页） 增加页面 留言墙（区） 增加相册页（包括美图展示） 添加网盘 增加体系页（思维导图） RSS订阅 增加个人导航页（工具、网站、影视等） 图像logo 更改 （适应黑夜模式） 评论管理 关注我改成公众号（公众号还未准备）** 网站运行时间 pv/uv 图片懒加载 （以及与相册的bug) Bug 修复 关注 Follow 弹出二维码在移动设备未在中间弹出 黑夜模式下 底部刷新变黑明显慢于其他部分 night.js初次加载报Cannot read property ‘toString’ of null的问题 黑夜下valine 评论 代码格式形式白 Display 布局 三栏展示：Home 、Archives、Categories、Tags、Movies 双栏展示： Post、 单栏展示： About 、Gallery、Links 纯静态/未渲染：Tricks : navs(先不弄了) Record 记录 page.layout 判断 type 将主题所用的字体放到本地，弃用 loli CDN 在黑夜模式作者imaegoo的帮助下解决 night.js 报错问题 将相册图片放到了又拍云cdn 上了 图片资源放在又拍云 Plan 期望 音乐部件 除文章页外不加载不必要插件 友链页整改 Profile 文档 hexo官方文档里对于变量的说明 hexo官方文档里对于辅助函数的说明 ejs嵌入开发各个标签的含义 bulma框架中文文档","link":"/posts/Icarus-record/"},{"title":"Cplex 编程方法(OPL)","text":"OPL是ILOG团队为运筹学研究者定制的一种优化建模语言。","link":"/posts/Cplex_OPL-program/"},{"title":"Java SE 基础系列笔记 (2)","text":"描述继承相关练习： 发红包案例 要求群主发普通红包。某群有多名成员，群主给成员发普通红包。普通红包的规则： 群主的一笔金额，从群主余额中扣除，平均分成n等份，让成员领取。 成员领取红包后，保存到成员余额中。 请根据描述，完成案例中所有类的定义以及指定类之间的继承关系，并完成发红包的操作。 实现1234567891011121314151617181920212223242526272829303132333435363738394041package com.demo01;/** * @ClassName: User * @Description: ToDo * @author: Aimer * @date: 2020/2/15 21:36 * version: 1.0 */public class User { private String name; private int money; public User() { } public User(String name, int money) { this.name = name; this.money = money; } public void show(){ System.out.println(\"我是\"+ name + \",我有多少钱：\"+ money); } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.demo01;import java.util.ArrayList;/** * @ClassName: Manager * @Description: 群主类 * @author: Aimer * @date: 2020/2/15 21:39 * version: 1.0 */public class Manager extends User { public Manager(){ } public Manager(String name, int money) { super(name, money); } //totalMoney 总共发的红包 count 为份数 public ArrayList&lt;Integer&gt; send(int totalMoney, int count){ //首先需要一个集合，用来存储若干个红包的金额 ArrayList&lt;Integer&gt; redList = new ArrayList&lt;&gt;(); //看下群主自己的钱够不够 int leftMoney = super.getMoney();//群主当前余额 if (totalMoney&gt;leftMoney){ System.out.println(\"余额不足\"); return redList;//空集合 } //扣钱（包括将最后除不尽余下的钱加到集合最后一个里） super.setMoney(leftMoney-totalMoney); int avg = totalMoney/count; int mod =totalMoney%count; for (int i = 0; i &lt; count-1; i++) { redList.add(avg); } int last = avg+mod;//最后一个红包 redList.add(last); return redList; }} 1234567891011121314151617181920212223242526272829package com.demo01;import java.util.ArrayList;import java.util.Random;/** * @ClassName: Member * @Description: 成员类 * @author: Aimer * @date: 2020/2/15 21:42 * version: 1.0 */public class Member extends User { public Member() { } public Member(String name, int money) { super(name, money); } public void receive(ArrayList&lt;Integer&gt; list){ //从多个红包中随便取一个红包（一个集合中的索引值） int index = new Random().nextInt(list.size()); //根据索引从集合中删除，得到红包 int delta = list.remove(index); //当前成员自己本来有多少钱 int money = super.getMoney(); super.setMoney(money+delta); }} 12345678910111213141516171819202122232425262728293031323334353637package com.demo01;import java.util.ArrayList;/** * @ClassName: LucyRed * @Description: 实现发红包案例 * @author: Aimer * @date: 2020/2/15 21:44 * version: 1.0 */public class LucyRed { public static void main(String[] args) { Manager manager = new Manager(\"群主\",100); Member one = new Member(\"成员A\",0); Member two = new Member(\"成员B\",0); Member three = new Member(\"成员C\",0);// 打印初始红包金额 manager.show(); one.show(); two.show(); three.show(); System.out.println(\"================\"); //群主发红包啦 ArrayList&lt;Integer&gt; redList = manager.send(20,3); //成员收红包 one.receive(redList); two.receive(redList); three.receive(redList); manager.show(); one.show(); two.show(); three.show(); }} 运行","link":"/posts/JavaSE02/"},{"title":"Java SE 基础系列笔记 (1)","text":"开启 JAVA 学习之旅 IDEA常用快捷键 快捷键 功能 Alt+4 打开程序运行窗口 Alt+Enter 导入包，自动修正代码 Ctrl+Y 删除光标所在行 Ctrl+D 复制光标所在行的内容到下一行 Ctrl+Alt+L 格式化代码 Ctrl+/ 单行注释，再按取消注释 Ctrl+Shift+/ 选中代码注释，多行注释 ，再按取消注释 Alt+Ins 自动生成代码，toString，get，set等方法 Alt+Shift+上下 移动当前代码行 Shift+f6 重构-重命名 (包、类、方法、变量、甚至注释等) IDEA代码自动补全 代码缩写 代码补全 psvm public static void main(String[] args) { } 循环数.fori for (int i = 0; i &lt; 循环数; i++) { } sout System.out.println(); 基础语法小记 成员变量是直接定义在类中的，在成员方法外边。 成员方法不要写 static 关键字。 当一个对象作为参数，传递到方法当中时，传递的是对象的地址值。 对于基本类型中的 boolean 值，Getter 方法一定要写成 isXxx 的形式，而 SetXxx 规则不变。 对于 Private 成员变量，通过类成员方法间接访问。 当方法的局部变量和类的成员变量重名的时候，就近优先使用局部变量。如需访问类成员变量，使用 this.成员变量名。 通过堆调用的方法，谁就是 this 。 Java Bean （满足四要求） 通过 super.成员变量名/方法 访问父类成员变量/方法。 重写/覆盖/覆写（Override) 与重载（Overload）区别在于参数列表是否一样。 可以通过写 @Override 来安全检测方法是不是有效的正确覆盖重写。 Overrid (重写)注意事项：子类方法的返回值必须小于等于父类方法的返回值范围。【Object类是所有类的公共最高父类】子类方法的权限必须大于等于父类方法的权限修饰符。【public &gt; protected &gt; (default) &gt;private】 继承中，子类构造方法默认隐含 “super()”调用，子类对象先调用父类构造，后执行子类构造。子类构造可以通过super关键字调用父类重载构造（必须是子类构造方法的第一个且唯一的语句)。 super 和 this 两种构造调用，不能同时使用。 使用抽象类和抽象方法：不能直接创建 new 抽象类对象；必须用一个子类来继承抽象父类；子类必须覆盖重写抽象父类当中的抽象方法（去掉 abstract 关键字，补上方法体大括号）。 在子类 extend 关键字上，通过 alt+ Enter ,实现抽象类方法的覆写。 使用 Alt + Insert 调用方法。【注意：很多电脑F12和Insert是同一个键，所以 Alt+Insert 和 Alt+F12 是冲突的，当我们按下 Alt+Insert 的时候其实触动的是 Alt+F12，大家应该知道想要触动Insert得用到 Fn(功能键)+Insert，所以想要触动 Alt+Insert 就得是 Fn(功能键)+Alt+Insert 才行】","link":"/posts/JavaSE01/"},{"title":"Java SE 基础系列笔记 (4)","text":"JAVA 接口学习 接口方法定义1234567891011121314151617181920212223242526272829303132package com.demo02;// 接口是多个类的公共规范// Java7 中接口中可包含常量、抽象方法// Java8 中额外可包含默认方法、静态方法// Java9 中额外可包含私有方法// 私有方法包括普通私有方法和静态私有方法// 前者解决多个默认方法之间重复代码问题(接口中关键字为 private )// 后者解决多个静态方法之间重复代码问题(接口中关键字为 private static)// 接口中的共有方法不应该让实现类使用（Java8 无法展示，代码略）// 接口中的常量要使用大写，用下划线分隔且必须赋值关键字public interface MyInterface { //常量 public static final String NUM_OF_CLASS = \"接口常量执行\";//public static final 可以省略 // 抽象方法 public abstract void AbsMethod01();// public abstract 可不写 void AbsMethod02(); // 默认方法 public default void DefalutMethod01(){ System.out.println(\"默认方法01执行\"); } public default void DefalutMethod02(){ System.out.println(\"默认方法02执行\"); } // 静态方法 public static void StaticMethod(){ System.out.println(\"静态方法不能通过实现类调用\"); }} 接口方法实现12345678910111213141516171819202122232425package com.demo02;// 接口的实现类// 接口不能直接使用，必须有一个实现类来实现该接口// 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法// 注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须定义为抽象类（Abstract)// 注意事项：不能通过接口实现类的对象来调用接口当中的静态方法，只能通过接口名称调用public class InterfaceImp implements MyInterface { @Override public void AbsMethod01() { System.out.println(\"接口的第一个方法执行\"); } @Override public void AbsMethod02() { System.out.println(\"接口的第二个方法执行\"); } //默认方法01覆写，02未覆写 @Override public void DefalutMethod01() { System.out.println(\"覆写了接口01的默认方法\"); }} 123456789101112131415161718192021222324252627package com.demo02;/** * @ClassName: InterfaceUse * @Description: 接口实现 * @author: Aimer * @date: 2020/2/16 15:02 * version: 1.0 */public class InterfaceUse { public static void main(String[] args) { InterfaceImp IImp = new InterfaceImp(); IImp.AbsMethod01(); IImp.AbsMethod02(); System.out.println(\"==========\"); //如果接口实现类没有覆写接口的默认方法，将使用接口的默认方法 IImp.DefalutMethod01(); IImp.DefalutMethod02(); // 接口静态方法调用 MyInterface.StaticMethod(); //只能用接口名.方法调用 //常量调用 System.out.println(MyInterface.NUM_OF_CLASS); }} 接口方法运行 接口内容小结1.成员变量其实是常量，格式： [public] [static] [final] 数据类型 常量名称 = 数据值; 注意：常量必须进行赋值，而且一旦赋值不能改变。常量名称完全大写，用下划线进行分隔 2.接口中最重要的就是抽象方法，格式： [public] [abstract] 返回值类型 方法名称(参数列表); 注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。 3.从Java 8开始，接口里允许定义默认方法，格式： [public] default 返回值类型 方法名称(参数列表) { 方法体 } 注意：默认方法也可以被覆盖重写。 4.从Java 8开始，接口里允许定义静态方法，格式： [public] static 返回值类型 方法名称(参数列表) { 方法体 } 注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法。 5.从Java 9开始，接口里允许定义私有方法，格式： 普通私有方法：private 返回值类型 方法名称(参数列表) { 方法体 } 静态私有方法：private static 返回值类型 方法名称(参数列表) { 方法体 } 注意：private的方法只有接口自己才能调用，不能被实现类或别人使用。 实现多个接口public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB{} 12345678一个类可以同时实现多个接口，但直接父类是唯一的接口没有静态代码块后者构造方法如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法接口与接口之间是多继承的多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】","link":"/posts/JavaSE04/"},{"title":"Java SE 基础系列笔记 (3)","text":"JAVA 多态学习 多态格式多态：父类引用指向子类对象 父类名称 对象名 = new 子类名称 或者： 接口名称 对象名 = new 实现类名称 成员变量及方法使用在多态的代码当中，成员方法的访问规则是： 看 new的是谁，就优先用谁，没有就向上找。 成员变量，编译看左边，运行还看左边。 成员方法，编译看左边，运行看右边。 对象的转型向上转型向上转型，就是多态写法。向上转型一定是安全的，从小范围转向大范围。 格式： 父类名称 对象名 = new 子类名称 含义： 右侧创建一个子类对象，把它当做父类来看待使用。 向下转型对象的向下转型，其实是一个还原的动作。 格式：子类名称 对象名 = (子类名称) 父类对象 含义： 将父类对象，还原为本来的子类对象。 注意事项： 向下转型需要 对象 instanceof 类名称来判断前面的对象能不能当做后面类型的实例。 笔记本 USB 接口实例USB12345678910111213package com.demo03;/** * @ClassName: USB * @Description: USB接口 * @author: Aimer * @date: 2020/2/17 19:54 * version: 1.0 */public interface USB { public abstract void open(); public abstract void close();} Computer123456789101112131415161718192021222324252627282930313233package com.demo03;import java.security.Key;/** * @ClassName: Computer * @Description: 计算机类 * @author: Aimer * @date: 2020/2/17 19:56 * version: 1.0 */public class Computer { public void powerOn(){ System.out.println(\"笔记本开机\"); } public void powerOff(){ System.out.println(\"笔记本关机\"); } // 使用USB public void useDevice(USB usb){ usb.open(); if (usb instanceof Mouse){ Mouse mouse = (Mouse) usb;//向下转型 mouse.click(); }else if(usb instanceof Keyboard){ Keyboard keyboard = (Keyboard) usb;//向下转型 keyboard.type(); } usb.close(); }} Mouse123456789101112131415161718192021222324252627package com.demo03;/** * @ClassName: Mouse * @Description: 鼠标 * @author: Aimer * @date: 2020/2/17 20:03 * version: 1.0 *///鼠标就是一个 USB 设备public class Mouse implements USB { @Override public void open() { System.out.println(\"打开鼠标\"); } @Override public void close() { System.out.println(\"关闭鼠标\"); } public void click(){ System.out.println(\"鼠标点击\"); }} Keyboard1234567891011121314151617181920212223242526package com.demo03;/** * @ClassName: Keyboard * @Description: 键盘 * @author: Aimer * @date: 2020/2/17 20:42 * version: 1.0 *///键盘也是个USB设备public class Keyboard implements USB{ @Override public void open() { System.out.println(\"打开键盘\"); } @Override public void close() { System.out.println(\"关闭键盘\"); } public void type(){ System.out.println(\"键盘输入\"); }} 实现1234567891011121314151617181920212223package com.demo03;/** * @ClassName: DemoC * @Description: 实现 * @author: Aimer * @date: 2020/2/17 20:05 * version: 1.0 */public class DemoC { public static void main(String[] args) { Computer computer = new Computer(); computer.powerOn(); // 多态写法 USB usbMouse = new Mouse(); // 左父右子 computer.useDevice(usbMouse); // 未使用 Keyboard keyboard = new Keyboard(); computer.useDevice(keyboard); computer.powerOff(); }}","link":"/posts/JavaSE03/"},{"title":"Java SE 基础系列笔记 (5)","text":"JAVA 内部类学习 内部类的分类 成员内部类 局部内部类（包含匿名内部类） 成员内部类的定义123456修饰符 class 外部类名称{ 修饰符 class 内部类名称{ //... } //... } 注意：内用外，随意访问；外用内，需要内部类对象。 成员内部类的使用间接方式通过外部类对象，调用外部类的方法，里面间接使用内部类Heart。 EXP: 1234567891011121314151617181920212223package com.demo04内部类;public class Body { private String name = \"某某 \"; public String getName() { return name; } public void setName(String name) { this.name = name; } public void method(){ new Heart().beat();// 外部类调用内部类方法 } // 内部类 public class Heart{ public void beat(){ System.out.println(name+\"beat\"); } }} 123456789package com.demo04内部类;public class HeartBody { public static void main(String[] args) { Body body = new Body(); body.method(); }} 直接方式公式： 12类名称 对象名 = new 类名称()；外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称; 以上面例子使用： Body.Heart heart = new Body().new Heart(); 注意：如果内部类要访问外部类的同名变量，格式为 外部类名称 . this.外部类成员变量名。 局部内部类的定义如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。 ​ 格式： 1234567修饰符 class 外部类名称{ 修饰符 返回值类型 外部类方法名称{ class 内部类名称{ //... } }} 注意：只有当前所属的方法才能使用它。 先小节一下类的权限修饰符： ​ public &gt; protected &gt; default &gt; private 定义一个类时，权限修饰符规则： 外部类： public / (default) 成员内部类： public/protected/(default)/private 局部内部类：什么都不能写！！！ 注意事项：局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是有效final的。 备注： 从Java8+开始，只要局部变量事实不变，那么final关键字可以省略。 匿名内部类何种情况需要匿名内部类？ 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次。 123接口名称 对象名 = new 接口名称（）{ //覆盖重写所有抽象方法 }； exp: 一般方法以及匿名内部类方法： 123456789101112package com.demo05匿名内部类;/** * @ClassName: Interfaceo * @Description: 接口 * @author: Aimer * @date: 2020/2/24 20:21 * version: 1.0 */public interface Interfaceo { void print();} 123456789101112131415package com.demo05匿名内部类;/** * @ClassName: InterCom * @Description: 实现接口方法类 * @author: Aimer * @date: 2020/2/24 20:28 * version: 1.0 */public class InterCom implements Interfaceo{ @Override public void print() { System.out.println(\"类实现接口\"); }} 1234567891011121314151617181920212223package com.demo05匿名内部类;/** * @ClassName: InterMy * @Description: 两种方法实现接口 * @author: Aimer * @date: 2020/2/24 20:22 * version: 1.0 */public class InterMy { public static void main(String[] args) { InterCom interCom = new InterCom(); interCom.print(); Interfaceo interfaceo = new Interfaceo() { @Override public void print() { System.out.println(\"匿名内部类实现\"); } }; interfaceo.print(); }} 匿名内部类注意事项对格式 new 接口名称（）{}进行解析： new 代表创建对象的动作 接口名称就是匿名内部类需要实现哪个接口 {~}其中才是匿名内部类的内容 还要注意： 匿名内部类，在【创建对象】时，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么必须使用单独定义的实现类。 匿名对象,在【调用方法】的时候，只能调用唯一一次。如果希望同一个对象调用多次方法，那么必须给对象起个名字。 匿名内部类是省略了【实现类/子类】,但是匿名对象是省略了【对象名称】。 exp： 123456new Interfaceo(){ @Override public void print() { System.out.println(\"匿名对象打印\"); }}.print(); 其它 类、接口可以作为成员变量类型 123456hero.setSkill(new Skill() { @Override public void use() { System.out.println(\"hhaha\"); }}); 接口可以作为方法的参数或者返回值","link":"/posts/JavaSE05/"},{"title":"Java SE 基础系列笔记 (6)","text":"常用 JAVA API(一) 学习 Scannerexp: 12345678910package com.demo09;import java.util.Scanner;public class demoScn { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int num = sc.nextInt(); String str = sc.next(); System.out.println(num+str); }} 匿名对象exp: 123456789101112131415161718192021222324package com.demo09;import java.util.Scanner;public class demoNum { public static void main(String[] args) { methodParam(new Scanner(System.in)); Scanner sc = methodReturn(); int num = sc.nextInt(); System.out.println(\"hhajfi\"); } // 匿名对象作为方法参数 public static void methodParam(Scanner sc) { int num = sc.nextInt(); System.out.println(num); } // 匿名对象作为返回值 public static Scanner methodReturn(){ return new Scanner(System.in); }} Randomexp: 123456789import java.util.Random;public class demoRan { public static void main(String[] args) { Random r = new Random(); int num = r.nextInt(); System.out.println(num); }} 注意：使用 nextInt(n) 为左闭右开区间。 猜数字小游戏12345678910111213141516171819202122232425262728package com.demo10;import java.util.Random;import java.util.Scanner;//猜数字游戏public class demoGame { public static void main(String[] args) { Random r = new Random(); int randomNum = r.nextInt(100) + 1;//[1,100] Scanner sc = new Scanner(System.in); while (true) { System.out.println(\"请输入：\"); int guessNum = sc.nextInt(); if (guessNum &lt; randomNum) { System.out.println(\"小了\"); } else if (guessNum &gt; randomNum) { System.out.println(\"大了\"); } else { System.out.println(\"中了\"); break; } } System.out.println(\"Over!!!\"); }} ArrayListArrayList(集合) 的长度是可以随意变化的。 ArrayList&lt;E&gt; 其中 E 为泛型，只能是引用类型。 exp: 123456789101112131415161718import java.util.ArrayList;public class demoARRM { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"李白\"); list.add(\"张飞\"); list.add(\"伽罗\"); list.add(\"干将\"); System.out.println(list); System.out.println(list.get(1)); String whoRemoved = list.remove(2); System.out.println(whoRemoved); int size = list.size(); //获取长度 System.out.println(size); }} 12345678910111213import java.util.ArrayList;public class ArrayListeach { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"A\"); list.add(\"B\"); list.add(\"C\"); list.add(\"D\"); for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } }} 存储基本类型：使用包装类（大写） 注意： Integer character String字符串是常量,效果上相当于 char[]字符数组，但是底层原理是byte[]字节数组。 三种构造方法以及直接创建1234public String()public String(char[] array)public String(byte[] array)String str1 = \"hello\" exp: 1234567891011121314151617package com.demo14字符串;public class DemoStr { public static void main(String[] args) { String str1 = new String(); char[] charArray = {'a','b','c'}; String str2 = new String(charArray); byte[] byteArray = {97,98,99}; String str3 = new String(byteArray); String str4 = \"hello\"; System.out.println(str1 + str2 + str3 + str4); }} 注意： 使用 ==比较的是对象的地址值，要用 a.equals(b) 比较字符串内容。 最好用 常量.equals(变量)，不然会报空指针异常错误 使用 equalsIgnoreCase 忽略大小写。 String 当中与获取相关的常用方法 用法 含义 public int length() 获取字符串当中含有的字符个数，拿到字符串长度 public String concat(String str) 将当前字符串和参数字符串拼接成为返回值新的字符串 public charAt(int index) 获取指定索引位置的单个字符 public int indexOf(string str) 查找参数字符串在本字符串当中首次出现的索引位置，无返回-1值 字符串截取 截取参数 效果 public String substring(int begin,int end) 截取从begin 开始，一直到end结束，中间的字符串 public String substring(int index) 截取从参数位置一直到字符串末尾，返回新字符串 字符串转换 方法 效果 public char[] toCharArray() 将当前字符串拆分成为字符数组作为返回值 public byte[] getBytes() 获得当前字符串底层的字节数组 public String replace(CharSequence oldString,CharSequence newString) 将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串 字符串分割按照参数规则将字符串分成若干部分： public String split(String regex) 注意事项： regex 为正则，要按原文句点 . 进行划分，必须写 \\\\. 。 static无论是成员变量还是成员方法，如果有了 static, 推荐使用类名称进行调用。 注意： 静态不能访问非静态 原因：因为在内存当中是先有静态内容，后有非静态内容。 注意： 静态方法中不能使用 this 原因： this 代表当前对象，通过谁调用的方法，谁就是当前对象。 静态代码块123public class 类名称{ static {}} 特点：当第一次用到本类时，静态代码执行唯一的一次，比构造方法先执行。 Arrays 方法 效果 public static String toString(数组) 将参数数组变成字符串 public static void sort(数组) 按照生序对数组的元素进行排序 备注： 如果是数值，sort 默认按照升序从小到大。 如果是字符串，sort 默认按照字母升序。 如果是自定义的类型，那么这个自定义的类需要有Comparable 或者Comparator 接口的支持（今后学习） Math 方法 效果 public static double abs(double num) 获取绝对值 public static double ceil(double num) 向上取整 public static double floor(double num) 向下取整 public static double round(double num) 四舍五入 备注： Math.PI 代表近似圆周率 （double) Math 小练习要求： 计算 -10.8 到 5.9 之间，绝对值大于 6 或者小于 2.1 的整数有多少个？ 分析： 既然已经确定了范围，用 for 循环。 起点位置 -10.8 应该转换成为 -10，两种方法： 2.1 可以使用 Math.ceil 方法，向上（向正方向）取整。 2.2 强制转换为 int ,自动舍弃所有小数位。 每一个数字都是整数，所以步进表达式应该是 num ++,这样每次都是 +1的。 如何拿到绝对值，用 Math.abs 方法。 一旦发现了应该数字，需要让计数器 ++ 进行统计。 备注： 如果使用 Math.ceil 方法， -10.8 可以变成 -10.0 . 注意 double 也是可以进行 ++ 的。 exp : 123456789101112131415public class DemoMath { public static void main(String[] args) { int count = 0; double min = -10.8; double max = 5.9; for(int i = (int) min;i&lt;max;i++){ int abs = Math.abs(i); if(abs&gt; 6||abs&lt;2.1){ System.out.println(i); count++; } } System.out.println(\"All:\"+count); }}","link":"/posts/JavaSE06/"},{"title":"Java SE 基础系列笔记 (7)","text":"常用 JAVA API 学习 （二） Object类toString 重写打印对象中的属性值 equals 重写比较对象属性值 注意： 用对象工具类 objects.equals() 比较更加健壮。 exp 123456789101112131415package com.demo18;import com.demo17.Student;import java.util.Objects;public class RT { public static void main(String[] args) { Student stu1 = new Student(\"lsk\",12); Student stu2 = new Student(\"lsk\",12); System.out.println(stu1.equals(stu2));// 重写 equals String a = \"aaa\"; String b = null;// System.out.println(b.equals(a));//空指针不能调用方法 System.out.println(Objects.equals(a,b)); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.demo17;import java.util.Objects;public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }// 覆写 toString @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }// 覆写 equals @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age &amp;&amp; Objects.equals(name, student.name); }} Date类 使用 System.currentTimeMillis() 获取距离时间原点的毫秒值 使用 .getTime() 效果同上 使用 Date( 参数l ) 带参数构造使毫秒转为日期 使用 toLocalString 根据本地格式转换日期对象 空参 1234567891011121314import java.util.Date;public class demoDate1 { public static void main(String[] args) { Date date = new Date(); System.out.println(date); Date d1 = new Date(0l); System.out.println(d1); Date d2 = new Date(); System.out.println(d2.getTime()); System.out.println(System.currentTimeMillis()); }} DateFormat 类DateFormat 是日期/时间格式化子类的抽象类，不能直接使用，需要其子类 SimpleDateFormat , 这个类需要一个模式（格式）来指定货解析的标准。 构造方法如下： public SimpleDateFormat(String pattern) 其中 pattern为日期时间的自定义格式。 格式规则: 标识字母（区分大小写） 含义 y 年 M 月 d 日 H 时 m 分 s 秒 使用 SimpleDateFormat 的 format 方法按照指定模式，把日期格式化符合模式的字符串。 使用其 parse 方法把符合模式的字符串，解析为 Date 日期。 exp: 1234567891011121314151617181920212223package com.demo20;import sun.security.provider.Sun;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;public class demoD { public static void main(String[] args) throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日HH时mm分ss秒\"); Date date = new Date(); System.out.println(date); System.out.println(sdf.format(date)); Date date1 = sdf.parse(\"2020年03月08日19时59分42秒\"); System.out.println(date1); }}//结果如下/* Sun Mar 08 20:40:03 CST 2020 2020年03月08日20时40分03秒 Sun Mar 08 19:59:42 CST 2020 */ 小练习：粗略计算年龄12345678910111213141516171819package com.demo21;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Scanner;//粗略计算年龄public class DemoMath { public static void main(String[] args) throws ParseException { Scanner sc = new Scanner(System.in); System.out.println(\"请输入您的出生日期:（格式为 yyyyMMdd)\"); String receiveDate = sc.next(); SimpleDateFormat sdf= new SimpleDateFormat(\"yyyyMMdd\"); Date birthdayDate = sdf.parse(receiveDate); long brthdayDateTime = birthdayDate.getTime(); long todayTime = new Date().getTime(); System.out.println((todayTime - brthdayDateTime)/1000/60/60/24/365); }} CalendarCalendar类为抽象类，提供了很多操作日历字段的方法，使用其静态方法 getInstance()返回子类对象。 成员方法 作用 int get(int n) 获取指定日历字段信息 void set(int n,int value) 将指定日历字段设置为指定的值 void add(int n,int value) 将指定日历字段增加或减少指定的值 Date getTime() 转换为 Date 对象 System public static long currentTimeMills()： 返回以毫秒为单位的当前时间。 public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length): 将数组中指定的数据拷贝到另一个数组中。 StringBuilder（字符串缓冲区）构造方法 public StringBuilder():构造一个空的容器。 public StringBuilder(String str): 构造一个StringBuilder容器，并将字符串添加进去。 成员方法 public StringBuilder append(): 添加容易类型的字符串形式，返回当前对象自身（可链式编程）。 public StringBuilder reverse(): 反转内容。 public String toString(): 将当前 StringBuilder 对下转换为 String 对象。 包装类装箱与拆箱装箱：把基本类型的数据包装到包装类中（基本类型的数据- &gt;包装类） 拆箱：在包装类中取出基本类型的数据（包装类-&gt;基本数据类型） exp: 1234567891011121314151617181920public class demoBox { public static void main(String[] args) { //装箱 //构造方法 Integer in1 = new Integer(1); System.out.println(in1); Integer in2 = new Integer(\"1\"); System.out.println(in2); // 静态方法 Integer in3 = Integer.valueOf(1); System.out.println(in3); Integer in4 = Integer.valueOf(\"1\"); System.out.println(in4); //拆箱 int i = in1.intValue(); System.out.println(i); }} 自动装箱与自动拆箱（&gt;JDK1.5)1234567891011121314import java.util.ArrayList;public class demoBoo { public static void main(String[] args) { //自动装箱 Integer in = 1;//相当于 Integer in = new Integer(1) //自动拆箱 in = in +2; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); //list.add(new Integer(1) int a = list.get(0);//list.get(0).intValue }} 基本类型与字符串之间的转换 直接 基本数据类型 + “”（常用） 使用 toString(value)、parseInt等（注意格式）","link":"/posts/JavaSE07/"},{"title":"Java SE 基础系列笔记 (8)","text":"Java 集合（Collection）学习 Collection 概述Collection 单列集合类的跟接口，用于存储一系列符合某种规则的元素，包括 java.util.List 与 java.util.Set。 其中，list 特点是元素有序、元素可重复、存储有序，而set 特点是元素无序，不可重复，存储无序。 下面前三为 List 接口实现类，后三是 Set 接口实现类。 Vector略 ArrayList （重点）底层数组实现，查询块、增删慢 LinkedList底层链表实现，查询慢，增删块 TreeSet底层二叉树实现，一般用于排序 HashSet （重点）底层哈希表+（红黑树）实现的，无索引、不可以存储重复元素、存取无序 LinkedHashSet底层哈希表+链表实现的，无索引、不可以存储重复元素、可以保存存取顺序 Collection 常用方法 方法 功能 boolean add(E e) 添加元素 boolean remove(E e) 删除元素 void clear() 清空元素 boolean contains(E e) 判断是否包含元素 boolean isEmpty() 判断是否为空 int size() 集合长度 Object [ ] toArray（） 集合转数组 exp 1234567891011121314151617181920212223242526272829303132333435363738394041package com.demo24;import java.util.ArrayList;import java.util.Collection;public class demo23 { public static void main(String[] args) { Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); coll.add(\"hello\"); coll.add(\"hello\"); coll.add(\"sb\"); coll.add(\"sb\"); coll.add(\"sb\"); System.out.println(coll); //[hello, hello, sb, sb, sb] coll.remove(\"sb\"); coll.remove(\"sb\"); System.out.println(coll); boolean result = coll.remove(\"sb\"); System.out.println(result); coll.clear(); System.out.println(coll); coll.add(\"hero\"); coll.add(\"hero\"); coll.add(\"hero\"); System.out.println(coll.contains(\"her\")); System.out.println(coll.isEmpty()); System.out.println(coll.size()); Object[] arr = coll.toArray(); for (Object o : arr) { //jdk1.5新特性 System.out.println(o); } }}// [hello, hello, sb, sb, sb]// [hello, hello, sb]// true// []// false// false// 3// hero// hero// hero Iterator 迭代器 boolean hasNext() 如果仍有元素可以迭代，则返回 true，没有返回 false。 E next() 返回迭代的下一个元素。 Collection 接口中 iterator()方法返回迭代器的实现类对象。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class demoIterator { public static void main(String[] args) { Collection&lt;String&gt; coll = new ArrayList&lt;&gt;(); coll.add(\"刘亦菲\"); coll.add(\"刘诗诗\"); coll.add(\"刘德华\"); coll.add(\"刘德华\"); coll.add(\"admin\"); for (String s : coll) { System.out.println(s); } Iterator&lt;String&gt; it = coll.iterator(); while (it.hasNext()){ System.out.println(it.next()); } System.out.println(\"--------\"); for(String s: coll){//增强for循环 System.out.println(s); } }}/*刘亦菲刘诗诗刘德华刘德华admin刘亦菲刘诗诗刘德华刘德华admin--------刘亦菲刘诗诗刘德华刘德华admin*/","link":"/posts/JavaSE08/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment TestTestTestTestTestTestTestTestTestTestTestTestTestTestTest","link":"/posts/hello-world/"},{"title":"计算机网络基础","text":"计算机网络知识 计算机网络组成 组成：软件、硬件、协议。 工作方式：边缘部分和核心部分。边缘部分由各主机构成，边缘部分利用核心部分提供的服务，使众多主机之间能够互相通信并交换信息或共享信息；核心部分由许多路由器实现互连，向网络边缘中的主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信。 功能组成：通信子网和资源子网。资源子网由主机，终端，和终端控制器组成，提供访问网络和处理数据；通信子网由网络通信设备和通信链路组成，提供数据传输通信。 计算机网络体系结构OSI参考模型（七层模型）OSI（Open System Interconnect）：开放式系统互联 OSI 参考模型 功能及相关协议 应用层（Application Layer） 提供为应用软件而设的接口，以设置与另一应用软件之间的通信。协议例如: HTTP、HTTPS、FTP、TELNET、SSH、SMTP、POP3、DNS、DHCP等。 表示层（Presentation Layer） 主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等操作，也就是把计算机能识别的东西转换成人类能识别的定西。格式例如：JPEG、ASCll、DECOIC、加密格式等。 会话层（Session Layer） 通过传输层建立数据传输的通路，在系统间发起会话或接受会话的请求。 传输层（Transport Layer） 定义了一些传输数据的协议和端口号，主要将从网络层接受的数据进行分段传输，到达目的地后进行重组，也负责向两台主机进程之间的通信提供通用的数据传输服务。这一层的数据叫段。协议例如 TCP 、UDP等。 网络层（Network Layer） 主要将从数据链路层接受的数据进行IP地址的封装和解封装。这一层工作的设备为路由器，这层的数据叫数据报。协议例如：IP、RIP、ICMP、BGP等。 数据链路层（Data Link Layer） 主要将从物理层接受的数据进行mac地址(网卡的地址)的封装与解封装。在这一层工作的设备为交换机，这层的数据叫帧。协议例如 Wi-Fi 、ARP、IEEE802.3、ATM、PPP、CSMA/CD等。 物理层（Physical Layer） 主要定义物理设备标准。如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等，这层的数据叫比特。还包括例如数据线、调制解调器等。 TCP/IP 四层模型与 OSI 对比如下表： OSI 七层模型 TCP/IP 四层模型 应用层 应用层 表示层 应用层 会话层 应用层 传输层 运输层 网络层 网络层 数据链路层 网络接口层 物理层 网络接口层 网络体系图 TCP 三次握手TCP 报文结构","link":"/posts/computer-network-basic/"},{"title":"《念念手记》观后感","text":"Typecho 站还在时写的一篇电影水文。 趁着周末，跟朋友去看了《念念手纪》。初看海报，还以为是散发着青春恋爱主题的影片，观后它更像是部纯爱片，纯的成分占了多数，而正是这种日式纯爱吸引了我。而这部影片传达的主题，不仅仅展现了青春时会有青涩爱恋，更多的是对生命的思考，对人与人之间建立纽带的期盼，纯爱的主题在爱情的映衬下而显得更加感人。正如影片所说的那样，“谁都不知道明天会发生什么，所以，才要珍惜过每一天，每一刻。“没有人能够随随便便的经过过你身旁，而那些能过走到你心房里的那些人，我们应该倍加珍惜，你的出现，拯救了自己，也拯救了他们。我想说的是，无论是什么人，是亲人也好，恋人也好，朋友也好，只要那个人在你的生命里划过痕迹，就请爱他们，做出你的决定与行动，哪怕是最后的陪伴。记住，也要爱你自己，珍惜当下的一切，在有限的人生里爱上一些人，爱上自己，这是件多么令人欣慰的事。 看完影片，心里还是有点不舒服。对于男主的表现，不满意。女生生前以她的方式在拯救男主，希望男主春树能够脱离自己的小世界，然而女生不在了，男生工作了却要辞职，当老师还是那副精神萎靡的样子，她是希望男主能够多与别人交流，希望他能结交一些朋友，而他还是这副样子，算什么男人?影片最后，男主似乎是醒悟了，有所改变，但我总觉得不够，他还有很长的路要走，不然对不起她对他的期望。我就来以我的观点来先评价下男主的性格，一个在班上没有存在感的男生，哦吼，好像有那么一点点我以前的影子，不过他真的很胆小、不敢与别人有过多交流，不想麻烦别人，也不接受别人的好意，这是有多么的“不食人间烟火”，他唯一的爱好，估计是呆在图书馆一个人看书，不想有人打扰。永远也叫不醒一个装睡的人，没有她的出现，很难想象他以后的情况。男生终究是太傻，或者我干脆说他太笨，还有些冷漠。一个女生，强颜欢笑，想方设法想让男生明白些重要的事，而他，由拒绝到被动接受，到被动感动，到被动做出些改变，没有自己的想法，没有想为她做些什么的行动。她是病人，你也是病人，没有爱是理所当然的，所以请将你的爱及时传达给她。或许，人无完人，人总是在经历了种种，才会有些许改变，些许改变，或许也已足够。 很难想象一个即将因胰脏坏了要死去的活泼女生在得知情况后还能坦然微笑面对，她想了很多，不告诉最好的朋友她活不了多久的消息，为了是不让朋友伤心难过，早早的写了遗书；与志贺春树成为关系好同学，希望他能有所改变，喜欢她；安排好了在生命的最后日子要做完的事，对生命的热爱，可见一斑。女主樱木很是聪明，又善解人意，活泼可爱，坚强乐观，可上天总是爱开玩笑，越是美的，就越不公平，连最后的几个月的生命，也被突如其来的一场意外提前结束了年轻的生命，留下了男主的难过与懊悔。若是遇上这样一个性格基本完美的女生，你的生命就不应该平庸，要活出你的意义。 “我死了的话，我的胰脏都给你吃哦”，这句话很让人触动，女主樱良听说过，如果能吃掉某人的胰脏，就能够永远活在那个吃的人身体里。她是多么的希望男主能够永远记得她。她知道他无法把她这个将死之人当作女朋友，她在她的信中说道：“我知道你不想把任何一个恋人或者朋友的位置，留给我这个快要死掉的人”，她内心一定是很难过的，而她却表现的很自然，这其中的心疼只有她一个人能够体会得到。伴随着痛苦，伴随这快乐，她也决意要挺过去，为了她所要完成的事。两个人是不是恋人，是不是朋友，已经都不重要了，有种感情比平常的爱情更加的迷人，更感人。她安排好了自己的遗书，却没能想到自己死的比预期还早，没能进行第二次旅行。生命不易，且行且珍惜。爱惜自己，爱你所爱的人，这很容易，也真的很难。 全片最煽情的那段，男主问樱良母亲，他能哭吗，那一刻，他嚎啕大哭，从一点点哭泣，到最后情不自禁的大哭，能感受的，有他的失落、难过、伤心、懊悔。。。我也禁不住哭了，这么好的一个女孩，说走就走了，真的不忍心啊。 可能我自己对男主有些期望过高了，以为他在后半段能为女生创造喜悦，然而他还没开始做，一切戛然而止，令人唏嘘。男生的性格有缺陷，若没有她，他将何去何从？当然，一切仍有变数。拯救，或许是电影反映的一个主题，但我想让大家明白，这也是我想对我自己说的：生命之中，并不是总有那个人会来拯救你的，更多的时候，你要自救，不让自己沉迷过往，退一万步来说，为那个生命中可能会来拯救你的人也好，还是没人来拯救你也好，就算为了你自己，为了生命本身，你也应该积极进取，离开自己的小岛。为你，可以千千万万遍。 樱花很美，美的让人害怕。日本的小清新作品中，有种人文关怀，有种超越男欢女爱的纯爱，很温暖，很治愈。没有亲吻，没有牵过手，跟激情无关，这与欧美片有很大不同，却能够通过人物内心感情的流露，来展示这一切的事物，这或许是我喜欢看日本人写的小说缘故吧。","link":"/posts/pancreas/"},{"title":"MySQL 学习笔记","text":"开始学习 MySQL 数据库","link":"/posts/MySQL-Study/"},{"title":"一些自用软件推荐","text":"一些自用软件（Win） Typora(Markdown编辑器，美而易用) FinalShell(SSH 客户端工具，支持文件管理，评价不一) 向日葵(远程控制软件，好像比 tv 好用) Chrome（浏览器，还是开发工具) Adobe After Effects（视觉效果和动态图形处理软件，没用过） IDLE (Python 开发工具，小白版，好用还是选 pycharm) Word (文字处理软件，不多说) 火绒（安全软件，很安静） 网易有道词典（支持截屏翻译，其它功能我好像不需要） Codeblocks(C/C++开发工具，小巧) IDM(多线程下载工具，配合chrome很舒服) Vs Code(代码编辑器/开发工具，内置Git，多扩展) VM VirtualBox(虚拟机) VMware Workstation(虚拟机) 网易云音乐(音乐云盘好评) Camtasia 9(专业录屏软件，非常好用) CPLEX(规划/优化软件) Adobe Photoshop (ps) 百度网盘 PotPlayer(本地视频播放器) IDEA (Java 开发工具) 爱思助手（苹果助手，可以用于ipad管理） Snipaste （截图工具） PicGo (图片上传工具) 冰点文库（百度文库下载器） 石墨/幕布/Xmind(思维导图及团队合作) Irfanview(图片浏览/管理) Bandzip(压缩工具) Disgenius(硬盘分区工具) Git(代码版本同步) 未完待续…","link":"/posts/self-use-software/"}],"tags":[{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"cplex","slug":"cplex","link":"/tags/cplex/"},{"name":"inherit","slug":"inherit","link":"/tags/inherit/"},{"name":"basic","slug":"basic","link":"/tags/basic/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"polymorphism","slug":"polymorphism","link":"/tags/polymorphism/"},{"name":"inner","slug":"inner","link":"/tags/inner/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"collection","slug":"collection","link":"/tags/collection/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"review","slug":"review","link":"/tags/review/"},{"name":"software","slug":"software","link":"/tags/software/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"OPL","slug":"OPL","link":"/categories/OPL/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"Movie","slug":"Movie","link":"/categories/Movie/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"}]}